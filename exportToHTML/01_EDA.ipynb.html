<html>
<head>
<title>01_EDA.ipynb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #5c6370;}
.s1 { color: #bbbbbb;}
.s2 { color: #d55fde;}
.s3 { color: #89ca78;}
.s4 { color: #d19a66;}
.s5 { color: #2bbac5;}
</style>
</head>
<body bgcolor="#282c34">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
01_EDA.ipynb</font>
</center></td></tr></table>
<pre><span class="s0">#%% md 
</span><span class="s1">&lt;!--Header--&gt; 
&lt;div style=&quot;background: #555&quot;&gt; 
    &lt;div style=&quot;background-color: #fff; color: black; padding-bottom: 20px; display: flex; justify-content: space-between; align-items: flex-start;&quot;&gt; 
        &lt;div style=&quot;width: 60%;&quot;&gt; 
            &lt;h1 style=&quot;margin: 16px&quot;&gt;TFG - Inteligencia Artificial&lt;/h1&gt; 
            &lt;p style=&quot;margin: 16px; padding-bottom: 0&quot;&gt;Junio de 2025&lt;/p&gt; 
        &lt;/div&gt; 
        &lt;div style=&quot;width: 40%; text-align: right&quot;&gt; 
            &lt;img src=&quot;https://www.uoc.edu/portal/_resources/common/imatges/marca_UOC/UOC_Masterbrand.jpg&quot; alt=&quot;Logo UOC&quot;&gt; 
        &lt;/div&gt; 
    &lt;/div&gt; 
    &lt;h2 style=&quot;color: #fff; text-align: justify; padding: 0 16px&quot;&gt;Aplicación de técnicas de IA fiable en la predicción del índice de calidad de vida en personas con tratamiento oncológico mediante aprendizaje automático.&lt;/h2&gt; 
    &lt;div style=&quot;padding: 20px; color: #fff&quot;&gt; 
        &lt;h4 style=&quot;margin: 0 0; padding: 0 0&quot;&gt;Pablo Pimàs Verge&lt;/h4&gt; 
        &lt;h5 style=&quot;margin: 0 0; padding: 0 0&quot;&gt;Grado en Ingeniería Informática&lt;/h5&gt; 
        &lt;h5 style=&quot;margin: 0 0 4px; padding: 0 0&quot;&gt;Inteligencia Artificial&lt;/h5&gt; 
        &lt;h4 style=&quot;margin: 8px 0 4px; padding: 0 0&quot;&gt;Dra. María Moreno de Castro&lt;/h4&gt; 
        &lt;h4 style=&quot;margin: 0 0; padding: 0 0&quot;&gt;Dr. Friman Sanchéz&lt;/h4&gt; 
    &lt;/div&gt; 
&lt;/div&gt; 
 
&lt;!--/Header--&gt; 
</span><span class="s0">#%% md 
</span><span class="s1"># Fase 2 
</span><span class="s0">#%% md 
</span><span class="s1"># Análisis exploratorio y preparación de los datos 
En el presente cuaderno se realizarán las tareas de exploración y preparación de los datos que serán utilizados durante todo el trabajo. Este proceso corresponde a la fase 2 del marco CRISP-DM y la planificación del proyecto. 
</span><span class="s0">#%% md 
</span><span class="s1">Los datos han sido compartidos por Gebert Pimrapat en el repositorio Mendeley Data [1] y corresponden a la encuesta realizada por la Charité – Universitätsmedizin Berlin, a mujeres en el inicio del tratamiento de cáncer de mama, entre 2016 y 2021.  
 
La encuesta consta de tres partes: datos basales socio-demográficos, formulario genérico para cáncer EORTC QLQ-C30 (C30) y módulo específico para cáncer de mama EORTC QLQ-C23 (C23). Para el trabajo se utilizarán los datos referentes a los índices calculados de los formularios C30 y C23. Por lo tanto, los objetivos del análisis y la preparación son los siguientes: 
 
- Separar el conjunto en los 3 dominios: basales, C30 y C23 
- Para los conjuntos C30 y C23: 
    - Analizar y explorar la calidad de los datos 
    - Preparar las variables para la utilización de los algoritmos basados en árboles de decisión 
    - Convertir la variable objetivo en 3 clases para la clasificación 
    - Separar los datos en los conjuntos de: entrenamiento, prueba, validación y calibración 
</span><span class="s0">#%% md 
</span><span class="s1">### Librerías y Configuración 
- Importación del software necesario para la manipulación, visualización y transformación de los datos.  
- Configuración del cuaderno y opciones de visualización 
</span><span class="s0">#%% 
# Importaciones</span>
<span class="s2">import </span><span class="s1">pandas </span><span class="s2">as </span><span class="s1">pd</span>
<span class="s2">import </span><span class="s1">math</span>
<span class="s2">import </span><span class="s1">numpy </span><span class="s2">as </span><span class="s1">np</span>
<span class="s2">import </span><span class="s1">seaborn </span><span class="s2">as </span><span class="s1">sns</span>
<span class="s2">import </span><span class="s1">matplotlib.pyplot </span><span class="s2">as </span><span class="s1">plt</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">sklearn.preprocessing </span><span class="s2">import </span><span class="s1">KBinsDiscretizer</span>
<span class="s0">#%% 
# Configuraciones</span>
<span class="s1">%matplotlib inline</span>
<span class="s1">warnings.filterwarnings(</span><span class="s3">&quot;ignore&quot;</span><span class="s1">)</span>
<span class="s1">pd.options.display.float_format = </span><span class="s3">'{:.2f}'</span><span class="s1">.format</span>
<span class="s1">plt.rc(</span><span class="s3">'font'</span><span class="s1">, size=</span><span class="s4">10</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">### Carga de los datos 
</span><span class="s0">#%% 
</span>
<span class="s1">file_path = </span><span class="s3">&quot;../data/Data_PROM_Baseline.xlsx&quot;</span>
<span class="s1">df = pd.read_excel(file_path, sheet_name=</span><span class="s3">&quot;Sheet1&quot;</span><span class="s1">)</span>
<span class="s0">#%% md 
</span><span class="s1">## 1 Análisis Exploratorio 
</span><span class="s0">#%% md 
</span><span class="s1">### 1.1 Funciones auxiliares 
Definición de funciones para el análisis y la exploración de los datos 
</span><span class="s0">#%% 
# Inspeccionar una columna de un dataframe</span>
<span class="s2">def </span><span class="s1">inspect_column(df: pd.DataFrame, column_name: str, max_unique: int = </span><span class="s4">50</span><span class="s1">) -&gt; pd.DataFrame:</span>
    <span class="s0">&quot;&quot;&quot; 
    Returns a DataFrame with two columns (&quot;Property&quot; and &quot;Value&quot;). Each row contains  
    a piece of information about the specified column, such as data type, null counts,  
    duplicates, descriptive statistics, and a limited set of unique values. 
    &quot;&quot;&quot;</span>
    <span class="s1">col_data = df[column_name]</span>
    <span class="s1">data_type = col_data.dtype</span>
    <span class="s1">null_count = col_data.isnull().sum()</span>
    <span class="s1">desc_series = col_data.describe(include=</span><span class="s3">'all'</span><span class="s1">)</span>

    <span class="s2">if not </span><span class="s1">isinstance(desc_series, pd.Series):</span>
        <span class="s1">desc_series = desc_series.iloc[</span><span class="s4">0</span><span class="s1">]</span>

    <span class="s1">desc_dict = {}</span>
    
    <span class="s2">for </span><span class="s1">key, val </span><span class="s2">in </span><span class="s1">desc_series.items():</span>
        <span class="s1">desc_dict[</span><span class="s3">f&quot;</span><span class="s5">{</span><span class="s1">key</span><span class="s5">}</span><span class="s3">&quot;</span><span class="s1">] = val</span>

    <span class="s1">unique_vals = col_data.dropna().unique().round(</span><span class="s4">2</span><span class="s1">)</span>

    <span class="s2">if </span><span class="s1">np.issubdtype(col_data.dtype, np.number):</span>
        <span class="s1">unique_vals = np.sort(unique_vals)</span>
        
    <span class="s1">unique_vals_limited = unique_vals[:max_unique].tolist()</span>

    <span class="s1">info_dict = {</span>
        <span class="s3">&quot;column_name&quot;</span><span class="s1">: column_name,</span>
        <span class="s3">&quot;dtype&quot;</span><span class="s1">: str(data_type),</span>
        <span class="s3">&quot;null_count&quot;</span><span class="s1">: null_count,</span>
        <span class="s3">&quot;unique_values&quot;</span><span class="s1">: unique_vals_limited,</span>
        <span class="s3">&quot;total_unique_values&quot;</span><span class="s1">: len(unique_vals),</span>
        <span class="s3">&quot;skew&quot;</span><span class="s1">: df[column_name].skew(),</span>
    <span class="s1">}</span>
    <span class="s1">info_dict.update(desc_dict)</span>

    <span class="s1">df_result = pd.DataFrame(</span>
        <span class="s1">list(info_dict.items()),</span>
        <span class="s1">columns=[</span><span class="s3">&quot;Property&quot;</span><span class="s1">, </span><span class="s3">&quot;Value&quot;</span><span class="s1">]</span>
    <span class="s1">)</span>

    <span class="s2">return </span><span class="s1">df_result</span>
<span class="s0">#%% 
# Inspeccionar todas las columnas de un dataframe</span>
<span class="s2">def </span><span class="s1">inspect_all_columns(df: pd.DataFrame, max_unique: int = </span><span class="s4">50</span><span class="s1">) -&gt; pd.DataFrame:</span>
    <span class="s0">&quot;&quot;&quot; 
    Creates a single DataFrame where each row corresponds to one column of 'df' 
    and each column of this resulting DataFrame is a property (dtype, null_count, 
    descriptive stats, etc.). 
    &quot;&quot;&quot;</span>
    <span class="s1">rows = []</span>

    <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">df.columns:</span>
        <span class="s1">col_data = df[col]</span>
        <span class="s1">data_type = col_data.dtype</span>
        <span class="s1">null_count = col_data.isnull().sum()</span>

        <span class="s1">desc_series = col_data.describe(include=</span><span class="s3">'all'</span><span class="s1">)</span>
        <span class="s2">if not </span><span class="s1">isinstance(desc_series, pd.Series):</span>
            <span class="s1">desc_series = desc_series.iloc[</span><span class="s4">0</span><span class="s1">]</span>
        <span class="s1">desc_dict = dict(desc_series)</span>

        <span class="s1">unique_vals = col_data.dropna().unique()</span>

        <span class="s2">if </span><span class="s1">np.issubdtype(data_type, np.number):</span>
            <span class="s1">unique_vals = np.sort(unique_vals)</span>
            <span class="s1">unique_vals = np.round(unique_vals, </span><span class="s4">2</span><span class="s1">)</span>

        <span class="s1">unique_vals_limited = unique_vals[:max_unique].tolist()</span>

        <span class="s1">row_dict = {</span>
            <span class="s3">&quot;dtype&quot;</span><span class="s1">: str(data_type),</span>
            <span class="s3">&quot;null_count&quot;</span><span class="s1">: null_count,</span>
            <span class="s3">&quot;unique_values&quot;</span><span class="s1">: unique_vals_limited,</span>
            <span class="s3">&quot;total_unique_values&quot;</span><span class="s1">: len(unique_vals),</span>
            <span class="s3">&quot;skew&quot;</span><span class="s1">: col_data.skew() </span><span class="s2">if </span><span class="s1">np.issubdtype(data_type, np.number) </span><span class="s2">else None</span><span class="s1">,</span>
        <span class="s1">}</span>
        <span class="s1">row_dict.update(desc_dict)</span>

        <span class="s1">rows.append(row_dict)</span>
    <span class="s1">df_result = pd.DataFrame(rows, index=df.columns)</span>
    <span class="s1">df_result.index.name = </span><span class="s3">&quot;column_name&quot;</span>

    <span class="s2">return </span><span class="s1">df_result</span>
<span class="s0">#%% 
# Graficar la distribución de todas las variables del dataframe</span>
<span class="s2">def </span><span class="s1">columns_distribution(df: pd.DataFrame):</span>

    <span class="s0">&quot;&quot;&quot; 
    Visualizes the distribution of columns present in a DataFrame. 
    :param df: dataframe containing columns of interest 
    &quot;&quot;&quot;</span>
    <span class="s1">cols = df.columns</span>

    <span class="s1">n_cols = </span><span class="s4">3</span>
    <span class="s1">n_rows = math.ceil(len(cols) / n_cols)</span>
    <span class="s1">fig, axes = plt.subplots(n_rows, n_cols, figsize=(n_cols * </span><span class="s4">5</span><span class="s1">, n_rows * </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">axes = axes.flatten()</span>

    <span class="s2">for </span><span class="s1">i, col </span><span class="s2">in </span><span class="s1">enumerate(cols):</span>
        <span class="s1">sns.histplot(data=df, x=col, kde=</span><span class="s2">True</span><span class="s1">, ax=axes[i])</span>
        <span class="s1">sns.despine()</span>
        <span class="s1">axes[i].set_title(col, fontsize=</span><span class="s4">16</span><span class="s1">)</span>
        <span class="s1">axes[i].set_xlabel(</span><span class="s3">''</span><span class="s1">)</span>

    <span class="s2">for </span><span class="s1">j </span><span class="s2">in </span><span class="s1">range(len(cols), len(axes)):</span>
        <span class="s1">fig.delaxes(axes[j])</span>

    <span class="s1">plt.tight_layout()</span>
    <span class="s1">plt.subplots_adjust(hspace=</span><span class="s4">0.5</span><span class="s1">)</span>
    <span class="s1">plt.show()</span>
<span class="s0">#%% 
# Visualizar valores nulos del dataframe por columna</span>
<span class="s2">def </span><span class="s1">view_missing_values(df):</span>
    <span class="s0">&quot;&quot;&quot; 
    Visualizes missing values of columns present in a DataFrame. 
    :param df: dataframe containing columns of interest 
    &quot;&quot;&quot;</span>
    <span class="s1">null_counts = df.isnull().sum()</span>
    <span class="s1">plt.figure(figsize=(</span><span class="s4">12</span><span class="s1">, </span><span class="s4">3</span><span class="s1">))</span>
    <span class="s1">sns.barplot(x=null_counts.index, y=null_counts.values)</span>
    <span class="s1">sns.despine()</span>
    <span class="s1">plt.xticks(rotation=</span><span class="s4">90</span><span class="s1">)</span>
    <span class="s1">plt.ylabel(</span><span class="s3">'Number of Null Values'</span><span class="s1">)</span>
    <span class="s1">plt.title(</span><span class="s3">'Null Values per Variable'</span><span class="s1">)</span>
    <span class="s1">plt.show()</span>
<span class="s0">#%% 
# Verificar columnas con las mismas filas nulas</span>
<span class="s2">def </span><span class="s1">check_rows_same_nulls(df: pd.DataFrame):</span>
    <span class="s0">&quot;&quot;&quot; 
    Checks for columns with the same null rows to be deleted. 
    :param df: dataframe containing columns of interest 
    &quot;&quot;&quot;</span>
    <span class="s1">missing_groups = {}</span>
    <span class="s2">for </span><span class="s1">col </span><span class="s2">in </span><span class="s1">df.columns:</span>
        <span class="s1">missing_indices = frozenset(df.index[df[col].isnull()])</span>
        <span class="s1">missing_groups.setdefault(missing_indices, []).append(col)</span>

    <span class="s2">for </span><span class="s1">missing_set, columns </span><span class="s2">in </span><span class="s1">missing_groups.items():</span>
        <span class="s2">if </span><span class="s1">len(columns) &gt; </span><span class="s4">1</span><span class="s1">:</span>
            <span class="s1">print(</span><span class="s3">&quot;Total rows with missing values:&quot;</span><span class="s1">, len(missing_set))</span>
            <span class="s1">print(</span><span class="s3">&quot;Variables with identical missing rows:&quot;</span><span class="s1">, columns)</span>
<span class="s0">#%% md 
</span><span class="s1">### 1.2 Diccionario 
</span><span class="s0">#%% md 
</span>

<span class="s1">#### Atributos Basales 
Información sobre aspectos socio-demográficos y la historia clínica de las pacientes en el momento del registro. 
 
- Age: edad, en años 
- weight: peso, en kg 
- height: altura, en cm 
- bmi: índice de masa corporal, en kg/cm$^2$ 
- marital_status: estado civil, 0: soltera | 1: en pareja | 2: separada | 3: viuda 
- education: nivel de educación, 0: bajo | 1: medio | 2: alto 
- alcohol: frecuencia del consumo de alcohol, 0: nunca | 1: ocasional | 2: semanal | 3: diaria 
- smokingstatus: fumadora, 0: no | 1: si | 2: ex fumadora 
- bust: dimensión del busto, de 1 a 13 hace referencia a los centímetros desde 65 hasta 125 con saltos de 5 
- cupsize: medida del busto con relación al contorno del dorso, de 1 a 9 hace referencia a las tallas desde AA hasta H 
- menstruation_firsttime_age: edad de la primera menstruación, en años 
- menopause_yn: estado de menopausia, 0: no | 1: si 
- birth_number: cantidad de partos, de 0 a 7 indica el número, 8 indica más de 7 
- pregnancy_number: cantidad de embarazos, de 0 a 7 indica el número, 8 indica más de 7 
- comorb_none: tiene comorbidades, 0: no | 1: si 
- comorb_heart: enfermedades coronarias, 0: no | 1: si 
- comorb_hypertension: hipertensión, 0: no | 1: si 
- comorb_paod: oclusión periférica arterial, 0: no | 1: si 
- comorb_diabetes: diabetes, 0: no | 1: si 
- comorb_kidney: enfermedades renales, 0: no | 1: si 
- comorb_liver: enfermedades hepáticas, 0: no | 1: si 
- comorb_stroke: ACV o derrames, 0: no | 1: si 
- comorb_neuological: enfermedades neurológicas, 0: no | 1: si 
- comorb_cancerlast5years: cancer en los últimos 5 años, 0: no | 1: si 
- comorb_depression: depresión, 0: no | 1: si 
- comorb_gastrointestinal: enfermedades gastrointestinales, 0: no | 1: si 
- comorb_endometriosis: endometriosis, 0: no | 1: si 
- comorb_arthritis: artritis, 0: no | 1: si 
- comorb_incontinence: incontinencia, 0: no | 1: si 
- comorb_uti: infecciones urinarias, 0: no | 1: si 
- cancer_breast: cancer de mama en los últimos 5 años, 0: no | 1: si 
- contraceptive_kind: uso de anticonceptivos, 0: ninguno | 1: oral | 2: inyección | 3: diafragma | 4: Hormonal | 5: implante | 6: Cobre DIU 
- pre_op: cirugía de cancer previa, 0: no | 1: si 
- cancer_kind_family_1: anttecedentes familiares de cancer de útero o mama, 0: no | 1: si 
- breastcancer_first: primer cancer de mama, 0: no | 1: si 
- diagnosis: diagnóstico, 1: cancer de mama | 2: DCIS | 3: fibroadenoma | 4: otros tipos 
- lateral: lado afectado, 0: izquierdo | 2: derecho | 3: ambos 
- histotype: tipo histológico de cancer, 0: tumor primario | 1: invasivo ductal | 2: invasivo lobular | 888: otro | 999: desconocido 
- gradeinv: grado, 0: grado 1 | 1: grado 2 | 2: grado 3 | 3: no especificado 
- erstatus: estado del receptor de estrógeno, 0: negativo | 1: positivo | 2: sin medición | 999: desconocido 
- prstatus: estado del receptor de progesterona, 0: negativo | 1: positivo | 2: sin medición | 999: desconocido 
- her2status: estado del receptor de HER2, 0: negativo | 1: positivo | 2: sin medición | 999: desconocido 
</span><span class="s0">#%% md 
</span><span class="s1">#### EORTC QLQ-C30 
Índices calculados del formulario genérico para cáncer (CORE), son de tipo decimal (float) continuo. 
 
- **ql: índice de calidad de vida (QoL), variable objetivo** 
- pf: funcionamiento físico 
- rf: funcionamiento de rol (actividades habituales y responsabilidades cotidianas laborales y domésticas) 
- ef: funcionamiento emocional 
- cf: funcionamiento cognitivo 
- sf: funcionamiento social 
- fa: fatiga 
- nv: náuseas y vómitos 
- pa: dolor 
- dy: disnea (dificultad para respirar) 
- sl: insomnio 
- ap: pérdida de apetito 
- co: constipado 
- di: diarrea 
- fi: dificultades financieras 
</span><span class="s0">#%% md 
</span><span class="s1">#### EORTC QLQ-C23 
Índices calculados del formulario específico para cancer de mama, son de tipo decimal (float) continuo. 
 
- brbi: imagen del propio cuerpo 
- brsef: funcionamiento sexual 
- brsee: disfrute sexual 
- brfu: perspectiva de futuro 
- brst: síntomas en el brazo 
- brbs: síntomas en la mama 
- bras: efectos secundarios de la terápia sistémica 
- brhl: afectación por la caída del cabello 
 
</span><span class="s0">#%% 
</span><span class="s1">view_missing_values(df)</span>
<span class="s0">#%% md 
</span><span class="s1">### 1.2 Dominio EORTC QLQ-C30 
 
En primer lugar, se creará un dataframe con los atributos del dominio C30 y se realizará el análisis exploratorio del conjunto. 
</span><span class="s0">#%% 
# Creación del dataframe C30</span>
<span class="s1">columns_C30 = [</span><span class="s3">'id'</span><span class="s1">, </span><span class="s3">'ql'</span><span class="s1">, </span><span class="s3">'pf'</span><span class="s1">, </span><span class="s3">'rf'</span><span class="s1">, </span><span class="s3">'ef'</span><span class="s1">, </span><span class="s3">'cf'</span><span class="s1">, </span><span class="s3">'sf'</span><span class="s1">, </span><span class="s3">'fa'</span><span class="s1">, </span><span class="s3">'nv'</span><span class="s1">, </span><span class="s3">'pa'</span><span class="s1">, </span><span class="s3">'dy'</span><span class="s1">, </span><span class="s3">'sl'</span><span class="s1">, </span><span class="s3">'ap'</span><span class="s1">, </span><span class="s3">'co'</span><span class="s1">, </span><span class="s3">'di'</span><span class="s1">, </span><span class="s3">'fi'</span><span class="s1">]</span>
<span class="s1">df_qlq_C30 = df[columns_C30]</span>
<span class="s0"># Asignación de nombres semánticos a las columnas</span>
<span class="s1">df_qlq_C30 = df_qlq_C30.rename(columns= {</span>
    <span class="s3">'ql'</span><span class="s1">: </span><span class="s3">'QoL'</span><span class="s1">,</span>
    <span class="s3">'pf'</span><span class="s1">: </span><span class="s3">'Physical functioning'</span><span class="s1">,</span>
    <span class="s3">'rf'</span><span class="s1">: </span><span class="s3">'Role functioning'</span><span class="s1">,</span>
    <span class="s3">'ef'</span><span class="s1">: </span><span class="s3">'Emotional functioning'</span><span class="s1">,</span>
    <span class="s3">'cf'</span><span class="s1">: </span><span class="s3">'Cognitive functioning'</span><span class="s1">,</span>
    <span class="s3">'sf'</span><span class="s1">: </span><span class="s3">'Social functioning'</span><span class="s1">,</span>
    <span class="s3">'fa'</span><span class="s1">: </span><span class="s3">'Fatigue'</span><span class="s1">,</span>
    <span class="s3">'nv'</span><span class="s1">: </span><span class="s3">'Nausea and vomiting'</span><span class="s1">,</span>
    <span class="s3">'pa'</span><span class="s1">: </span><span class="s3">'Pain'</span><span class="s1">,</span>
    <span class="s3">'dy'</span><span class="s1">: </span><span class="s3">'Dyspnea'</span><span class="s1">,</span>
    <span class="s3">'sl'</span><span class="s1">: </span><span class="s3">'Insomnia'</span><span class="s1">,</span>
    <span class="s3">'ap'</span><span class="s1">: </span><span class="s3">'Appetite loss'</span><span class="s1">,</span>
    <span class="s3">'co'</span><span class="s1">: </span><span class="s3">'Constipation'</span><span class="s1">,</span>
    <span class="s3">'di'</span><span class="s1">: </span><span class="s3">'Diarrhea'</span><span class="s1">,</span>
    <span class="s3">'fi'</span><span class="s1">: </span><span class="s3">'Financial difficulties'</span><span class="s1">,</span>
<span class="s1">})</span>
<span class="s0">#%% 
</span><span class="s1">inspect_all_columns(df_qlq_C30.drop(</span><span class="s3">'id'</span><span class="s1">, axis=</span><span class="s4">1</span><span class="s1">), max_unique=</span><span class="s4">50</span><span class="s1">)</span>
<span class="s0">#%% 
</span><span class="s1">columns_distribution(df_qlq_C30.drop(</span><span class="s3">'id'</span><span class="s1">, axis=</span><span class="s4">1</span><span class="s1">))</span>
<span class="s0">#%% 
</span><span class="s1">check_rows_same_nulls(df_qlq_C30)</span>
<span class="s0">#%% md 
</span><span class="s1">#### QoL - variable objetivo  
 
#### TODO  
</span><span class="s0">#%% md 
</span><span class="s1">#### Physical functioning 
 
Es el índice de funcionamiento físico calculado. 
</span><span class="s0">#%% 
</span>
<span class="s0">#%% md 
</span><span class="s1">### 1.3 Dominio EORTC QLQ-C23 
</span><span class="s0">#%% 
# Creación del dataframe C30</span>
<span class="s1">columns_C23 = [</span><span class="s3">'brst'</span><span class="s1">, </span><span class="s3">'brbi'</span><span class="s1">, </span><span class="s3">'brbs'</span><span class="s1">, </span><span class="s3">'brfu'</span><span class="s1">, </span><span class="s3">'brsee'</span><span class="s1">, </span><span class="s3">'brsef'</span><span class="s1">, </span><span class="s3">'bras'</span><span class="s1">, </span><span class="s3">'brhl'</span><span class="s1">]</span>
<span class="s1">df_qlq_C23 = df[columns_C23]</span>
<span class="s0"># Asignación de nombres semánticos a las columnas</span>
<span class="s1">df_qlq_C23 = df_qlq_C23.rename(columns= {</span>
    <span class="s3">'brst'</span><span class="s1">: </span><span class="s3">'Arm symptoms'</span><span class="s1">,</span>
    <span class="s3">'brbi'</span><span class="s1">: </span><span class="s3">'Body image'</span><span class="s1">,</span>
    <span class="s3">'brbs'</span><span class="s1">: </span><span class="s3">'Breast symptoms'</span><span class="s1">,</span>
    <span class="s3">'brfu'</span><span class="s1">: </span><span class="s3">'Future perspective'</span><span class="s1">,</span>
    <span class="s3">'brsee'</span><span class="s1">: </span><span class="s3">'Sexual enjoyment'</span><span class="s1">,</span>
    <span class="s3">'brsef'</span><span class="s1">: </span><span class="s3">'Sexual functioning'</span><span class="s1">,</span>
    <span class="s3">'bras'</span><span class="s1">: </span><span class="s3">'Systemic therapy side effects'</span><span class="s1">,</span>
    <span class="s3">'brhl'</span><span class="s1">: </span><span class="s3">'Upset by hair loss'</span><span class="s1">,</span>
<span class="s1">})</span>
<span class="s0">#%% 
</span><span class="s1">inspect_all_columns(df_qlq_C23)</span>
<span class="s0">#%% 
</span><span class="s1">columns_distribution(df_qlq_C23)</span>
<span class="s0">#%% 
</span><span class="s1">check_rows_same_nulls(df_qlq_C23)</span>
<span class="s0">#%% md 
</span><span class="s1">### 1.4 Dominio EORTC QLQ-C30 U EORTC QLQ-C23 
</span><span class="s0">#%% 
</span><span class="s1">df_QLQ = pd.concat([df_qlq_C30, df_qlq_C23], axis=</span><span class="s4">1</span><span class="s1">)</span>
<span class="s1">df_QLQ.drop([</span><span class="s3">'Upset by hair loss'</span><span class="s1">, </span><span class="s3">'Sexual enjoyment'</span><span class="s1">], axis=</span><span class="s4">1</span><span class="s1">, inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">df_QLQ.dropna(inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s0">#%% 
</span><span class="s1">inspect_all_columns(df_QLQ)</span>
<span class="s0">#%% 
</span><span class="s1">columns_distribution(df_QLQ.drop(</span><span class="s3">'id'</span><span class="s1">, axis=</span><span class="s4">1</span><span class="s1">))</span>
<span class="s0">#%% 
</span><span class="s1">corr_matrix = df_QLQ.drop(</span><span class="s3">'id'</span><span class="s1">, axis=</span><span class="s4">1</span><span class="s1">).corr()</span>

<span class="s1">plt.figure(figsize=(</span><span class="s4">12</span><span class="s1">, </span><span class="s4">10</span><span class="s1">))</span>
<span class="s1">sns.heatmap(corr_matrix, annot=</span><span class="s2">True</span><span class="s1">, cmap=</span><span class="s3">'coolwarm'</span><span class="s1">, fmt=</span><span class="s3">&quot;.2f&quot;</span><span class="s1">)</span>
<span class="s1">plt.title(</span><span class="s3">&quot;Correlation Matrix&quot;</span><span class="s1">)</span>
<span class="s1">plt.show()</span>
<span class="s0">#%% 
</span>
<span class="s0">#%% md 
</span><span class="s1">### 2 Preaparación de los datos 
</span><span class="s0">#%% 
</span><span class="s1">discretizer = KBinsDiscretizer(n_bins=</span><span class="s4">3</span><span class="s1">, encode=</span><span class="s3">'ordinal'</span><span class="s1">, strategy=</span><span class="s3">'uniform'</span><span class="s1">)</span>
<span class="s1">df_qlq_C30_null = df_qlq_C30[df_qlq_C30.isnull().any(axis=</span><span class="s4">1</span><span class="s1">)].copy()</span>
<span class="s1">df_qlq_C30.dropna(axis=</span><span class="s4">0</span><span class="s1">, inplace=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s1">df_qlq_C30[</span><span class="s3">'QoL_bins'</span><span class="s1">] = discretizer.fit_transform(df_qlq_C30[[</span><span class="s3">'QoL'</span><span class="s1">]])</span>
<span class="s1">df_qlq_C30[</span><span class="s3">'QoL_bins'</span><span class="s1">].value_counts()</span>
<span class="s0">#%% 
# Gráfica de la distribución</span>
<span class="s1">sns.histplot(data=df_qlq_C30, x=</span><span class="s3">'QoL_bins'</span><span class="s1">, kde=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s0">#%% 
</span></pre>
</body>
</html>